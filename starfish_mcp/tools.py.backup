"""MCP tools for Starfish operations."""

import json
from typing import Any, Dict, List, Optional
import structlog

from mcp.types import (
    Tool,
    TextContent,
    CallToolResult,
    EmbeddedResource,
)

from .client import StarfishClient
from .models import StarfishError


logger = structlog.get_logger(__name__)


class StarfishTools:
    """MCP tools for Starfish API operations."""
    
    def __init__(self, client: StarfishClient):
        self.client = client
    
    def get_tools(self) -> List[Tool]:
        """Get list of available MCP tools."""
        return [
            Tool(
                name="starfish_query",
                description="Comprehensive file and directory search in Starfish with all available filters. This is the main search tool.",
                inputSchema={
                    "type": "object",
                    "properties": {
                        # Basic search parameters
                        "name": {
                            "type": "string",
                            "description": "Filename pattern (shell wildcards: *, ?). Examples: 'config.json', '*.pdf', 'test*'"
                        },
                        "name_regex": {
                            "type": "string", 
                            "description": "Filename regex pattern. Examples: '^.*\\.jpg$', '^config.*\\.json$'"
                        },
                        "path": {
                            "type": "string",
                            "description": "Parent path pattern (shell wildcards). Examples: '/home/*', 'Documents/Projects'"
                        },
                        "path_regex": {
                            "type": "string",
                            "description": "Parent path regex pattern. Examples: '^/home/.*', '^.*project.*$'"
                        },
                        
                        # File attributes
                        "file_type": {
                            "type": "string",
                            "enum": ["f", "d", "l", "b", "c", "s", "p"],
                            "description": "File type: 'f'=file, 'd'=directory, 'l'=symlink, 'b'=block device, 'c'=char device, 's'=socket, 'p'=FIFO"
                        },
                        "ext": {
                            "type": "string",
                            "description": "File extension (without dot). Examples: 'pdf', 'jpg', 'txt'"
                        },
                        "empty": {
                            "type": "boolean",
                            "description": "Find empty files and directories (true) or exclude them (false)"
                        },
                        
                        # Ownership and permissions
                        "uid": {
                            "type": "integer",
                            "description": "User ID (UID) to filter by. Examples: 0 (root), 1001"
                        },
                        "gid": {
                            "type": "integer",
                            "description": "Group ID (GID) to filter by. Examples: 0 (root group), 100"
                        },
                        "username": {
                            "type": "string",
                            "description": "Username (exact match). Examples: 'root', 'john', 'admin'"
                        },
                        "username_regex": {
                            "type": "string",
                            "description": "Username regex pattern. Examples: '^admin.*', '^.*_user$'"
                        },
                        "groupname": {
                            "type": "string", 
                            "description": "Group name (exact match). Examples: 'wheel', 'users', 'admin'"
                        },
                        "groupname_regex": {
                            "type": "string",
                            "description": "Group name regex pattern. Examples: '^admin.*', '.*_group$'"
                        },
                        "inode": {
                            "type": "integer",
                            "description": "Specific inode number to find"
                        },
                        
                        # File size and links
                        "size": {
                            "type": "string",
                            "description": "File size filter. Examples: '100' (exact), '10M-2G' (range), '>1GB', '<=500MB', 'eq:100KB', 'gt:1MB'"
                        },
                        "nlinks": {
                            "type": "string", 
                            "description": "Hard link count filter. Examples: '1' (exact), '2-5' (range), 'gte:3', 'lt:10'"
                        },
                        
                        # Case-insensitive versions
                        "iname": {
                            "type": "string",
                            "description": "Case-insensitive filename pattern. Examples: 'CONFIG.json', 'readme.*'"
                        },
                        "iusername": {
                            "type": "string",
                            "description": "Case-insensitive username match. Examples: 'ADMIN', 'John'"
                        },
                        "igroupname": {
                            "type": "string",
                            "description": "Case-insensitive group name match. Examples: 'WHEEL', 'Users'"
                        },
                        
                        # Directory depth
                        "depth": {
                            "type": "integer",
                            "description": "Exact directory depth from search root (0=root level, 1=immediate children)"
                        },
                        "maxdepth": {
                            "type": "integer",
                            "description": "Maximum directory depth to search (limits recursion)"
                        },
                        
                        # Permissions
                        "perm": {
                            "type": "string",
                            "description": "Permission matching. Examples: '644' (exact), '-u=r' (at least user read), '/222' (any write)"
                        },
                        
                        # Time filters
                        "mtime": {
                            "type": "string",
                            "description": "Modification time. Examples: '-1d' (within 1 day), '2024-01-01' (since date), '1-7d' (1-7 days ago)"
                        },
                        "ctime": {
                            "type": "string",
                            "description": "Change time (metadata). Examples: '-2h' (within 2 hours), '2024-01-01-2024-02-01' (date range)"
                        },
                        "atime": {
                            "type": "string",
                            "description": "Access time. Examples: '+30d' (older than 30 days), 'inf-1w' (older than 1 week)"
                        },
                        
                        # Query options
                        "search_all": {
                            "type": "boolean",
                            "description": "Search all history versions, not just current files"
                        },
                        "versions": {
                            "type": "boolean", 
                            "description": "Show all historical versions of matching entries"
                        },
                        "children_only": {
                            "type": "boolean",
                            "description": "Return only immediate children of specified path (optimization)"
                        },
                        "root_only": {
                            "type": "boolean",
                            "description": "Return only the exact entry specified by path (optimization)"
                        },
                        
                        # Tags
                        "tag": {
                            "type": "string",
                            "description": "Tag search with AND/OR/NOT logic. Examples: 'important', 'tag1 tag2' (AND), multiple calls for OR"
                        },
                        "tag_explicit": {
                            "type": "string",
                            "description": "Tags attached directly (not inherited). Supports AND/OR/NOT logic"
                        },
                        
                        # Search scope
                        "volumes_and_paths": {
                            "type": "array",
                            "items": {"type": "string"},
                            "description": "Limit search to specific volume:path combinations. Examples: ['home:', 'data:/projects']"
                        },
                        "zone": {
                            "type": "string",
                            "description": "Search within a specific zone name"
                        },
                        
                        # Output control
                        "limit": {
                            "type": "integer",
                            "default": 100,
                            "description": "Maximum number of results to return"
                        },
                        "sort_by": {
                            "type": "string",
                            "description": "Sort by fields. Examples: 'size', '-mtime', '+parent_path,size'"
                        },
                        "format_fields": {
                            "type": "string",
                            "description": "Space-separated fields to include. Default includes all common fields"
                        },
                        
                        # Performance
                        "use_async": {
                            "type": "boolean",
                            "default": False,
                            "description": "Use async query API for better performance on large searches"
                        }
                    },
                    "additionalProperties": False
                }
            ),
            
            Tool(
                name="starfish_list_volumes", 
                description="List all available Starfish volumes with details.",
                inputSchema={
                    "type": "object",
                    "properties": {},
                    "additionalProperties": False
                }
            ),
            
            Tool(
                name="starfish_list_zones",
                description="List all available Starfish zones with detailed information.",
                inputSchema={
                    "type": "object", 
                    "properties": {},
                    "additionalProperties": False
                }
            ),
            
            Tool(
                name="starfish_get_tagset",
                description="Get detailed information about a specific tagset.",
                inputSchema={
                    "type": "object",
                    "properties": {
                        "tagset_name": {
                            "type": "string",
                            "description": "Name of the tagset to retrieve (use ':' for default tagset)"
                        }
                    },
                    "required": ["tagset_name"]
                }
            )
        ]
    
    async def handle_tool_call(self, name: str, arguments: Dict[str, Any]) -> CallToolResult:
        """Handle MCP tool calls."""
        try:
            if name == "starfish_query":
                return await self._query(arguments)
            elif name == "starfish_list_volumes":
                return await self._list_volumes(arguments)
            elif name == "starfish_list_zones":
                return await self._list_zones(arguments)
            elif name == "starfish_get_tagset":
                return await self._get_tagset(arguments)
            else:
                return CallToolResult(
                    content=[TextContent(
                        type="text",
                        text=f"Unknown tool: {name}"
                    )],
                    isError=True
                )
        except StarfishError as e:
            logger.error("Starfish API error", tool=name, error=str(e))
            return CallToolResult(
                content=[TextContent(
                    type="text",
                    text=f"Starfish API error: {e}"
                )],
                isError=True
            )
        except Exception as e:
            logger.error("Tool execution failed", tool=name, error=str(e))
            return CallToolResult(
                content=[TextContent(
                    type="text",
                    text=f"Tool execution failed: {e}"
                )],
                isError=True
            )

    async def _query(self, arguments: Dict[str, Any]) -> CallToolResult:
        """Comprehensive Starfish query with all available filters."""
        # Extract parameters
        name = arguments.get("name")
        name_regex = arguments.get("name_regex")
        path = arguments.get("path")
        path_regex = arguments.get("path_regex")
        file_type = arguments.get("file_type")
        ext = arguments.get("ext")
        empty = arguments.get("empty")
        uid = arguments.get("uid")
        gid = arguments.get("gid")
        username = arguments.get("username")
        username_regex = arguments.get("username_regex")
        groupname = arguments.get("groupname")
        groupname_regex = arguments.get("groupname_regex")
        inode = arguments.get("inode")
        size = arguments.get("size")
        nlinks = arguments.get("nlinks")
        iname = arguments.get("iname")
        iusername = arguments.get("iusername")
        igroupname = arguments.get("igroupname")
        depth = arguments.get("depth")
        maxdepth = arguments.get("maxdepth")
        perm = arguments.get("perm")
        mtime = arguments.get("mtime")
        ctime = arguments.get("ctime")
        atime = arguments.get("atime")
        search_all = arguments.get("search_all")
        versions = arguments.get("versions")
        children_only = arguments.get("children_only")
        root_only = arguments.get("root_only")
        tag = arguments.get("tag")
        tag_explicit = arguments.get("tag_explicit")
        volumes_and_paths = arguments.get("volumes_and_paths", [])
        zone = arguments.get("zone")
        limit = arguments.get("limit", 100)
        sort_by = arguments.get("sort_by")
        format_fields = arguments.get("format_fields")
        use_async = arguments.get("use_async", False)
        
        # Build query parts
        query_parts = []
        
        # File type
        if file_type:
            query_parts.append(f"type={file_type}")
        
        # Names and paths
        if name:
            # Check if it's a regex pattern (starts with ^ or contains regex chars)
            if name.startswith('^') or any(c in name for c in ['(', ')', '[', ']', '{', '}', '|', '+', '?']):
                if not name.startswith('^'):
                    name = '^' + name
                query_parts.append(f"name-re={name}")
            elif '*' in name or '?' in name:
                # Shell pattern
                query_parts.append(f"name={name}")
            else:
                # Exact match for alphanumeric
                query_parts.append(f"name={name}")
        
        if name_regex:
            if not name_regex.startswith('^'):
                name_regex = '^' + name_regex
            query_parts.append(f"name-re={name_regex}")
        
        if path:
            query_parts.append(f"ppath={path}")
        
        if path_regex:
            if not path_regex.startswith('^'):
                path_regex = '^' + path_regex
            query_parts.append(f"ppath-re={path_regex}")
        
        # File attributes
        if ext:
            query_parts.append(f"ext={ext}")
        
        if empty is not None:
            if empty:
                query_parts.append("empty")
        
        if inode:
            query_parts.append(f"inode={inode}")
        
        # Ownership
        if uid is not None:
            query_parts.append(f"uid={uid}")
        
        if gid is not None:
            query_parts.append(f"gid={gid}")
        
        if username:
            query_parts.append(f"username={username}")
        
        if username_regex:
            if not username_regex.startswith('^'):
                username_regex = '^' + username_regex
            query_parts.append(f"username-re={username_regex}")
        
        if groupname:
            query_parts.append(f"groupname={groupname}")
        
        if groupname_regex:
            if not groupname_regex.startswith('^'):
                groupname_regex = '^' + groupname_regex
            query_parts.append(f"groupname-re={groupname_regex}")
        
        # Size and links
        if size:
            query_parts.append(f"size={size}")
        
        if nlinks:
            query_parts.append(f"nlinks={nlinks}")
        
        # Case-insensitive versions
        if iname:
            query_parts.append(f"iname={iname}")
        
        if iusername:
            query_parts.append(f"iusername={iusername}")
        
        if igroupname:
            query_parts.append(f"igroupname={igroupname}")
        
        # Depth
        if depth is not None:
            query_parts.append(f"depth={depth}")
        
        if maxdepth is not None:
            query_parts.append(f"maxdepth={maxdepth}")
        
        # Permissions
        if perm:
            query_parts.append(f"perm={perm}")
        
        # Time filters
        if mtime:
            query_parts.append(f"mtime={mtime}")
        
        if ctime:
            query_parts.append(f"ctime={ctime}")
        
        if atime:
            query_parts.append(f"atime={atime}")
        
        # Query options
        if search_all:
            query_parts.append("search-all")
        
        if versions:
            query_parts.append("versions")
        
        if children_only:
            query_parts.append("children-only")
        
        if root_only:
            query_parts.append("root-only")
        
        # Tags
        if tag:
            query_parts.append(f"tag={tag}")
        
        if tag_explicit:
            query_parts.append(f"tag-explicit={tag_explicit}")
        
        # Zone
        if zone:
            query_parts.append(f"zone={zone}")
        
        query = " ".join(query_parts)
        
        logger.info(
            "Executing comprehensive Starfish query",
            query=query,
            volumes_and_paths=volumes_and_paths,
            use_async=use_async,
            limit=limit
        )
        
        # Execute query
        if use_async and volumes_and_paths:
            response = await self.client.async_query(
                volumes_and_paths=volumes_and_paths,
                queries=[query] if query else [],
                format_fields=format_fields,
                limit=limit,
                sort_by=sort_by
            )
        else:
            volumes_param = volumes_and_paths[0] if volumes_and_paths else None
            response = await self.client.query(
                query=query,
                volumes_and_paths=volumes_param,
                format_fields=format_fields,
                limit=limit,
                sort_by=sort_by
            )
        
        # Convert to JSON result
        results = []
        for entry in response:
            result = {
                "id": entry.id,
                "filename": entry.filename,
                "parent_path": entry.parent_path,
                "full_path": entry.full_path,
                "volume": entry.volume,
                "size": entry.size,
                "type": "file" if entry.is_file else "directory",
                "uid": entry.uid,
                "gid": entry.gid,
                "mode": entry.mode
            }
            
            # Add time information if available
            if entry.create_time:
                result["create_time"] = entry.create_time.isoformat()
            if entry.modify_time:
                result["modify_time"] = entry.modify_time.isoformat()
            if entry.access_time:
                result["access_time"] = entry.access_time.isoformat()
            
            # Add tags if available
            if entry.all_tags:
                result["tags"] = entry.all_tags
            
            # Add zones if available
            if entry.zones:
                result["zones"] = [{"id": z.id, "name": z.name, "relative_path": z.relative_path} for z in entry.zones]
            
            results.append(result)
        
        return CallToolResult(
            content=[TextContent(
                type="text",
                text=json.dumps({
                    "query": query,
                    "filters_applied": {
                        "name": name,
                        "name_regex": name_regex,
                        "path": path,
                        "path_regex": path_regex,
                        "file_type": file_type,
                        "ext": ext,
                        "empty": empty,
                        "uid": uid,
                        "gid": gid,
                        "username": username,
                        "username_regex": username_regex,
                        "groupname": groupname,
                        "groupname_regex": groupname_regex,
                        "inode": inode,
                        "size": size,
                        "nlinks": nlinks,
                        "iname": iname,
                        "iusername": iusername,
                        "igroupname": igroupname,
                        "depth": depth,
                        "maxdepth": maxdepth,
                        "tag": tag,
                        "tag_explicit": tag_explicit,
                        "zone": zone
                    },
                    "search_scope": volumes_and_paths,
                    "use_async": use_async,
                    "total_found": len(results),
                    "limit": limit,
                    "results": results
                }, indent=2)
            )]
        )

    async def _list_volumes(self, arguments: Dict[str, Any]) -> CallToolResult:
        """List available Starfish volumes."""
        logger.info("Listing Starfish volumes")
        
        volumes = await self.client.list_volumes()
        
        # Convert to JSON
        results = []
        for volume in volumes:
            volume_data = {
                "id": volume.id,
                "name": volume.vol,
                "display_name": volume.display_name,
                "root": volume.root,
                "type": volume.type,
                "default_agent_address": volume.default_agent_address,
                "total_capacity": volume.total_capacity,
                "free_space": volume.free_space,
                "mounts": volume.mounts,
                "mount_opts": volume.mount_opts
            }
            
            # Add volume size info if available
            if volume.volume_size_info:
                volume_data["size_info"] = {
                    "number_of_files": volume.number_of_files,
                    "number_of_dirs": volume.number_of_dirs,
                    "sum_of_logical_sizes": volume.sum_of_logical_sizes,
                    "sum_of_physical_sizes": volume.sum_of_physical_sizes,
                    "sum_of_blocks": volume.sum_of_blocks
                }
            
            results.append(volume_data)
        
        return CallToolResult(
            content=[TextContent(
                type="text",
                text=json.dumps({
                    "total_volumes": len(results),
                    "volumes": results
                }, indent=2)
            )]
        )

    async def _list_zones(self, arguments: Dict[str, Any]) -> CallToolResult:
        """List available Starfish zones."""
        logger.info("Listing Starfish zones")
        
        zones = await self.client.list_zones()
        
        # Convert to JSON
        results = []
        for zone in zones:
            zone_data = {
                "id": zone.id,
                "name": zone.name,
                "paths": zone.paths,
                "managers": [{"system_id": m.system_id, "username": m.username} for m in zone.managers],
                "managing_groups": [{"system_id": g.system_id, "groupname": g.groupname} for g in zone.managing_groups],
                "restore_managers": zone.restore_managers,
                "restore_managing_groups": zone.restore_managing_groups,
                "tagsets": [{"name": t.name, "tag_names": t.tag_names} for t in zone.tagsets],
                "user_params": zone.user_params,
                "aggregates": {
                    "size": zone.aggregates.size if zone.aggregates else None,
                    "dirs": zone.aggregates.dirs if zone.aggregates else None,
                    "files": zone.aggregates.files if zone.aggregates else None,
                    "cost": zone.aggregates.cost if zone.aggregates else None
                } if zone.aggregates else None
            }
            results.append(zone_data)
        
        return CallToolResult(
            content=[TextContent(
                type="text",
                text=json.dumps({
                    "total_zones": len(results),
                    "zones": results
                }, indent=2)
            )]
        )

    async def _get_tagset(self, arguments: Dict[str, Any]) -> CallToolResult:
        """Get detailed information about a specific tagset."""
        tagset_name = arguments["tagset_name"]
        
        logger.info("Getting tagset details", tagset_name=tagset_name)
        
        tagset = await self.client.get_tagset(tagset_name)
        
        # Convert to JSON
        result = {
            "name": tagset.name,
            "zone_ids": tagset.zone_ids,
            "inheritable": tagset.inheritable,
            "pinnable": tagset.pinnable,
            "action": tagset.action.value if tagset.action else None,
            "tags": [{"id": tag.id, "name": tag.name} for tag in tagset.tags],
            "zones": []
        }
        
        # Add zone details
        for zone in tagset.zones:
            zone_data = {
                "id": zone.id,
                "name": zone.name,
                "paths": zone.paths,
                "managers": [{"system_id": m.system_id, "username": m.username} for m in zone.managers],
                "managing_groups": [{"system_id": g.system_id, "groupname": g.groupname} for g in zone.managing_groups],
                "tagsets": [{"name": t.name, "tag_names": t.tag_names} for t in zone.tagsets],
                "user_params": zone.user_params
            }
            result["zones"].append(zone_data)
        
        return CallToolResult(
            content=[TextContent(
                type="text",
                text=json.dumps(result, indent=2)
            )]
        )